module codegen/codegen-lex

imports

  nabl2/api
  libspoofax/stratego/debug
  signatures/TemplateLang-sig

  signatures/lex-sig
  codegen/-

rules

  /**
   * Converts the LEX Grammar to an SDF3 modules that contains at least a `lexical syntax` section.
   * Documentation notes about the constructors used in [at]type:
   * - Non-prefixed constructors originate from LEX.
   * - Constructors prefixed with `SDF3.` originate from SDF3.
   * - Primitive types are lowercase (e.g. string or int).
   *
   * @type Grammar -> SDF3.Module
   */
  lex-to-sdf3: Grammar(definitions, productionRules, _) -> Module(
      Unparameterized("test-lex")
    , []
    , [ SDFSection(LexicalSyntax(
          <conc> (<mapconcat(def-to-sdf3)> definitions, <mapconcat(rule-to-sdf3)> productionRules)
        ))
      ]
    )

  def-to-sdf3: Code(_) -> []
  def-to-sdf3: Name(name, rhs) -> [SdfProduction(
          SortDef(<capitalize-string> name), Rhs(<map(lhs-to-sdf3)> rhs), NoAttrs())]

  /** @type Rule(ID, List(RHS)) -> SDF3.SdfProduction */
  rule-to-sdf3: RuleWithRHS(lhss, _, rhs) -> [SdfProduction(
          SortDef(<capitalize-string> rhs), Rhs(<map(lhs-to-sdf3)> lhss), NoAttrs())]
  rule-to-sdf3: RuleWithLayout(lhss, _) -> [SdfProduction(
          Layout(), Rhs(<map(lhs-to-sdf3)> lhss), NoAttrs())]
  rule-to-sdf3: RuleWithError(lhss, _, _) -> [] // TODO do we really want to ignore the error?

  /** @type CharClass_(ranges, hyphen?) | Any() | Lit(string) | Or | Sequence -> SDF3.CharClass */
  lhs-to-sdf3: CharClass(ranges, None()) ->
          <charclass-to-sdf3> (ranges, 0)
  lhs-to-sdf3: CharClass(ranges, Some("-")) ->
          <charclass-to-sdf3> (<concat> [ranges, [Short("\\-")]], 0)
  lhs-to-sdf3: CharClassHyphen(ranges) ->
          <lhs-to-sdf3> CharClass([Short("\\-") | ranges], None())
  lhs-to-sdf3: CharClassBracket(ranges, hyphen) ->
          <lhs-to-sdf3> CharClass([Short("\\]") | ranges], hyphen)

  lhs-to-sdf3: CharClassNot(ranges, None()) ->
          <charclass-to-sdf3> (ranges, 1)
  lhs-to-sdf3: CharClassNot(ranges, Some("-")) ->
          <charclass-to-sdf3> (<concat> [ranges, [Short("\\-")]], 1)
  lhs-to-sdf3: CharClassNotHyphen(ranges) ->
          <lhs-to-sdf3> CharClassNot([Short("\\-") | ranges], None())
  lhs-to-sdf3: CharClassNotBracket(ranges, hyphen) ->
          <lhs-to-sdf3> CharClassNot([Short("\\]") | ranges], hyphen)

  lhs-to-sdf3: Any() -> CharClass(Comp(Simple(Present(Short("\\n")))))
  lhs-to-sdf3: Lit(str) -> Lit(str)
  lhs-to-sdf3: Ref(ID) -> Sort(ID)
  lhs-to-sdf3: Or(l, r) -> Alt(<lhs-to-sdf3> l, <lhs-to-sdf3> r)
  lhs-to-sdf3: Op(r, "?") -> Opt(<lhs-to-sdf3> r) 
  lhs-to-sdf3: Op(r, "+") -> Iter(<lhs-to-sdf3> r) 
  lhs-to-sdf3: Op(r, "*") -> IterStar(<lhs-to-sdf3> r) 
  lhs-to-sdf3: Sequence(h, t) -> Sequence(<lhs-to-sdf3> h, <map(lhs-to-sdf3)> t)

  // TODO union, parentheses, etc.

  /**
   * @type (ranges, negate) -> SDF3.{CharClass | Opt(CharClass) | Iter(CharClass) | IterStar(CharClass)}
   */
  charclass-to-sdf3: ([], 0) -> CharClass(Simple(Absent()))
  charclass-to-sdf3: (ranges, 0) -> CharClass(Simple(Present(<charranges-to-sdf3> ranges)))
  charclass-to-sdf3: ([], 1) -> CharClass(Comp(Simple(Absent())))
  charclass-to-sdf3: (ranges, 1) -> CharClass(Comp(Simple(Present(<charranges-to-sdf3> ranges))))

  /** @type List(Range | Short){length > 0} -> List(SDF3.Range | SDF3.Short) */
  charranges-to-sdf3: [h] -> <charrange-to-sdf3> h
  charranges-to-sdf3: [h | t] -> Conc(<charrange-to-sdf3> h, <charranges-to-sdf3> t)

  /** @type Range | Short -> SDF3.Range | SDF3.Short */
  charrange-to-sdf3: Short(c) -> Short(<ensure-char-escape> c)
  charrange-to-sdf3: Range(a, b) -> Range(<charrange-to-sdf3> a, <charrange-to-sdf3> b)

strategies

  /**
   * If the one-character string is not alphanumeric or already escaped, then escape it with a backslash
   *
   * @type string -> string
   * @fails If the input string is empty
   */
  ensure-char-escape = explode-string
                     ; ?[h | tail]
                     ; !h
                     ; if is-alphanum + equal(|'\') then ![<id>] else !['\', <id>] end
                     ; !(<id>, tail)
                     ; conc
                     ; implode-string

  /**
   * Capitalizes the first string of the character
   *
   * @type string -> string
   * @fails If the input string is empty
   */
  capitalize-string = explode-string ; ?[h | tail] ; ![<to-upper> h | tail] ; implode-string
