module codegen/codegen-lex

imports

  nabl2/api
  libspoofax/stratego/debug
  signatures/TemplateLang-sig

  signatures/lex-sig
  codegen/-

rules

  /**
   * Converts the LEX Grammar to an SDF3 modules that contains at least a `lexical syntax` section.
   * Documentation notes about the constructors used in [at]type:
   * - Non-prefixed constructors originate from LEX.
   * - Constructors prefixed with `SDF3.` originate from SDF3.
   * - Primitive types are lowercase (e.g. string or int).
   *
   * @type Grammar -> SDF3.Module
   */
  lex-to-sdf3: Grammar(definitions, productionRules, _) -> Module(
      Unparameterized("test-lex")
    , []
    , [ SDFSection(LexicalSyntax(
          <conc> (<mapconcat(def-to-sdf3)> definitions, <mapconcat(rule-to-sdf3)> productionRules)
        ))
      ]
    )

  def-to-sdf3: Code(_) -> []
  def-to-sdf3: Name(name, regex) -> [SdfProduction(
          SortDef(<capitalize-string> name), Rhs(<seq-to-list> <regex-to-sdf3> regex), NoAttrs())]

  /** @type Rule(Regex.*, List(Statement), ID?) -> SDF3.SdfProduction */
  rule-to-sdf3: RuleWithRHS(regex, _, token) -> [SdfProduction(
          SortDef(<capitalize-string> token), Rhs(<seq-to-list> <regex-to-sdf3> regex), NoAttrs())]
  rule-to-sdf3: RuleWithLayout(regex, _) -> [SdfProduction(
          Layout(), Rhs(<seq-to-list> <regex-to-sdf3> regex), NoAttrs())]
  rule-to-sdf3: RuleWithError(regex, _, _) -> [] // TODO do we really want to ignore the error?

  /** @type Regex.* -> SDF3.CharClass */
  regex-to-sdf3: CharClass(ranges, None())           -> <charclass-to-sdf3> (ranges, 0)
  regex-to-sdf3: CharClass(ranges, Some("-"))        -> <charclass-to-sdf3> (<concat> [ranges, [Short("\\-")]], 0)
  regex-to-sdf3: CharClassHyphen(ranges)             -> <regex-to-sdf3> CharClass([Short("\\-") | ranges], None())
  regex-to-sdf3: CharClassBracket(ranges, hyphen)    -> <regex-to-sdf3> CharClass([Short("\\]") | ranges], hyphen)

  regex-to-sdf3: CharClassNot(ranges, None())        -> <charclass-to-sdf3> (ranges, 1)
  regex-to-sdf3: CharClassNot(ranges, Some("-"))     -> <charclass-to-sdf3> (<concat> [ranges, [Short("\\-")]], 1)
  regex-to-sdf3: CharClassNotHyphen(ranges)          -> <regex-to-sdf3> CharClassNot([Short("\\-") | ranges], None())
  regex-to-sdf3: CharClassNotBracket(ranges, hyphen) -> <regex-to-sdf3> CharClassNot([Short("\\]") | ranges], hyphen)

  regex-to-sdf3: Any() -> CharClass(Comp(Simple(Present(Short("\\n")))))
  regex-to-sdf3: Lit(str) -> Lit(str)
  regex-to-sdf3: Ref(ID) -> Sort(ID)
  regex-to-sdf3: Or(l, r) -> Alt(<regex-to-sdf3> l, <regex-to-sdf3> r)
  regex-to-sdf3: Op(r, "?") -> Opt(<regex-to-sdf3> r)
  regex-to-sdf3: Op(r, "+") -> Iter(<regex-to-sdf3> r)
  regex-to-sdf3: Op(r, "*") -> IterStar(<regex-to-sdf3> r)
  regex-to-sdf3: Conc(h, t) -> Sequence(<regex-to-sdf3> h, <seq-to-list> <regex-to-sdf3> t)


  seq-to-list: Sequence(l, r) -> [l | r]
  seq-to-list: a -> [a]

  /**
   * @type (ranges, negate) -> SDF3.{CharClass | Opt(CharClass) | Iter(CharClass) | IterStar(CharClass)}
   */
  charclass-to-sdf3: ([], 0) -> CharClass(Simple(Absent()))
  charclass-to-sdf3: (ranges, 0) -> CharClass(Simple(Present(<charranges-to-sdf3> ranges)))
  charclass-to-sdf3: ([], 1) -> CharClass(Comp(Simple(Absent())))
  charclass-to-sdf3: (ranges, 1) -> CharClass(Comp(Simple(Present(<charranges-to-sdf3> ranges))))

  /** @type List(Range | Short){length > 0} -> List(SDF3.Range | SDF3.Short) */
  charranges-to-sdf3: [h] -> <charrange-to-sdf3> h
  charranges-to-sdf3: [h | t] -> Conc(<charrange-to-sdf3> h, <charranges-to-sdf3> t)

  /** @type Range | Short -> SDF3.Range | SDF3.Short */
  charrange-to-sdf3: Short(c) -> Short(<ensure-char-escape> c)
  charrange-to-sdf3: Range(a, b) -> Range(<charrange-to-sdf3> a, <charrange-to-sdf3> b)

strategies

  /**
   * If the one-character string is not alphanumeric or already escaped, then escape it with a backslash
   *
   * @type string -> string
   * @fails If the input string is empty
   */
  ensure-char-escape = explode-string
                     ; ?[h | tail]
                     ; !h
                     ; if is-alphanum + equal(|'\') then ![<id>] else !['\', <id>] end
                     ; !(<id>, tail)
                     ; conc
                     ; implode-string

  /**
   * Capitalizes the first string of the character
   *
   * @type string -> string
   * @fails If the input string is empty
   */
  capitalize-string = explode-string ; ?[h | tail] ; ![<to-upper> h | tail] ; implode-string
