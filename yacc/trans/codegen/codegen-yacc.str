module codegen/codegen-yacc

imports

  nabl2/api
  libspoofax/stratego/debug
  codegen/-
  signatures/yacc-sig
  signatures/modules/-

rules

  /** @type YACC AST -> SDF3 ContextFreeSyntax */
  yacc-to-sdf3: g @ Grammar(definitions, productionRules, _) -> Module(
      Unparameterized("test")
    , [Imports([Module(Unparameterized("test-lex"))])]
    , [ SDFSection(ContextFreeStartSymbols([<yacc-get-start-symbol> g]))
        // TODO take into account the definitions
      , SDFSection(
          ContextFreeSyntax(<mapconcat(rule-to-sdf3)> productionRules)
        )
      ]
    )

  /**
   * Gets the (first, and only) start symbol in the definitions list.
   * If there is no start symbol, it uses the lhs of the first grammar rule as start symbol.
   * When there are no rules, this strategy returns Sort("Undefined"),
   *   but this should never happen as NABL2 enforces the file to have at least one rule.
   *
   * @type YACC AST -> sdf3.Sort
   */
  yacc-get-start-symbol: Grammar(_, [], _) -> Sort("Undefined")
  yacc-get-start-symbol: Grammar(definitions, [Rule(firstSymbol, _) | _], _) ->
      <getfirst(\ Start(symbol) -> Sort(<capitalize-string> symbol) \)
          <+ !Sort(<capitalize-string> firstSymbol)> definitions

  /** @type Rule(ID, List(RHS)) -> List(SdfProductionWithCons) */
  rule-to-sdf3: Rule(lhs, rhss) ->
      <map-with-index(rhs-to-sdf3(|lhs, <length> filteredRhss))> filteredRhss
      // Removes all rules with `error` token in RHS. TODO do we really want to ignore the error?
      with filteredRhss := <remove-all(\ RHS(rhsSymbols, _, _) -> <getfirst(?Error())> rhsSymbols \)> rhss

  /** @type (String, Int) -> (Int, RHS(List(Identifier), Prec, Action)) -> SdfProductionWithCons */
  rhs-to-sdf3(|lhs, rhsAmount): (index, RHS(rhsSymbols, prec, _)) -> SdfProductionWithCons(
        SortCons(
          SortDef(<capitalize-string> lhs)
        , Constructor(<conc-strings> (
            <capitalize-string> lhs
            // Add an index to the constructor only if the amount of rules > 1
          , <?1 < !"" + (!index ; int-to-string)> rhsAmount)
          )
        )
      , Rhs(<rhs-symbols-to-sdf3> rhsSymbols)
      , NoAttrs()
      )

  /**
   * If RHS is empty, it produces an empty string on the RHS.
   * Else, it maps the identifiers on the RHS to sdf3 sorts and literals.
   *
   * @type List(Identifier) -> List(sdf3.Sort | sdf3.Lit)
   */
  rhs-symbols-to-sdf3: [] -> [Lit("\"\"")]
  rhs-symbols-to-sdf3: rhsSymbols -> <map(identifier-to-sdf3)> rhsSymbols

  /** @type Identifier -> sdf3.Sort | sdf3.Lit */
  identifier-to-sdf3: ID(str) -> Sort(<capitalize-string> str)
  identifier-to-sdf3: String(str) -> Lit(str)
  identifier-to-sdf3: SQString(str) -> Lit(<double-quote> <un-single-quote> str)

  /**
   * Capitalizes the first string of the character
   *
   * @type String -> String
   * @fails Never
   */
  capitalize-string: string -> res
    with [h|tail] := <explode-string> string
       ; newH := <to-upper> h
       ; res := <implode-string> [newH|tail]
