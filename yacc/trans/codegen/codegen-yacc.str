module codegen/codegen-yacc

imports

  nabl2/api
  libspoofax/stratego/debug
  signatures/TemplateLang-sig

  signatures/yacc-sig
  codegen/-

rules

  /**
   * Converts the YACC Grammar to an SDF3 modules that contains at least a `context-free syntax` section.
   * Documentation notes about the constructors used in [at]type:
   * - Non-prefixed constructors originate from YACC.
   * - Constructors prefixed with `SDF3.` originate from SDF3.
   * - Primitive types are lowercase (e.g. string or int).
   *
   * @type Grammar -> SDF3.Module
   */
  yacc-to-sdf3: g @ Grammar(definitions, productionRules, _) -> Module(
      Unparameterized("test")
    , [Imports([Module(Unparameterized("test-lex"))])]
    , <concat> [
        [ SDFSection(ContextFreeStartSymbols([<yacc-get-start-symbol> g])) ]
      , <yacc-get-priorities> g
        // TODO take into account the definitions
      , [ SDFSection(ContextFreeSyntax(<mapconcat(rule-to-sdf3)> productionRules)) ]
      ]
    )


  /**
   * Gets the (first, and only) start symbol in the definitions list.
   * If there is no start symbol, it uses the lhs of the first grammar rule as start symbol.
   * When there are no rules, this strategy returns Sort("Undefined"),
   *   but this should never happen as NABL2 enforces the file to have at least one rule.
   *
   * @type Grammar -> SDF3.Sort
   */
  yacc-get-start-symbol: Grammar(_, [], _) -> Sort("Undefined")
  yacc-get-start-symbol: Grammar(definitions, [Rule(firstSymbol, _) | _], _) ->
      <getfirst(\ Start(symbol) -> Sort(<capitalize-string> symbol) \)
          <+ !Sort(<capitalize-string> firstSymbol)> definitions


  /**
   * Optinally returns an SDF section with context-free priorities.
   * The priorities are in reverse order with respect to the definition in YACC, to maintain semantics.
   *
   * @type Grammar -> List(SDF3.SDFSection){length <= 1}
   */
  yacc-get-priorities: Grammar(definitions, productionRules, _) -> result
    with filteredDefs := <reverse> <filter(?Left(_, _) <+ ?Right(_, _) <+ ?NonAssoc(_,_))> definitions
       ; groups := <map(assoc-rule-to-sdf3(|productionRules))> filteredDefs
       ; result := <\[] -> []\ <+ \ groups -> [ SDFSection(ContextFreePriorities([ Chain(groups) ])) ] \> groups

  /** @type Left | Right | NonAssoc -> SDF3.AssocRefGroup */
  assoc-rule-to-sdf3(|productionRules): associativity#([_, ids]) -> AssocRefGroup(
      <assoc-to-sdf3> associativity
    , <mapconcat(lookup-constructor-from-identifier(|productionRules))> ids
    )

  /**
   * Returns the SDF3 associativity constructor based on the constructor symbol from YACC
   * @type string -> SDF3.Left | SDF3.Right | SDF3.NonAssoc
   */
  assoc-to-sdf3: "Left" -> Left()
  assoc-to-sdf3: "Right" -> Right()
  assoc-to-sdf3: "NonAssoc" -> NonAssoc()

  /**
   * Associativity rules can defined by their (SQ)String tokens, e.g. `%left '+'`.
   * In that case, this strategy looks up all constructors that contain this token on their RHS.
   * When a rule is defined with an ID, e.g. `%left UMINUS`,
   *   the constructors that are annotated with `%prec UMINUS` are looked up.
   *
   * @param productionRules : List(Rule)    The original YACC production rules to look up the Identifier in.
   * @type Identifier -> List(SDF3.SortConsRef(Sort, Constructor)))
   */
  // TODO for IDs, look up the constructors with corresponding %prec rule(s)
  // TODO for Strings, look up the constructors containing this token on their RHS.
  lookup-constructor-from-identifier(|productionRules): ID(name) -> 
      [ SortConsRef(Sort("Expr"), Constructor("Expr2")) ]
  lookup-constructor-from-identifier(|productionRules): String(str) ->
      [ SortConsRef(Sort("Expr"), Constructor("Expr2")) ]
  lookup-constructor-from-identifier(|rs): SQString(str) -> <lookup-constructor-from-identifier(|rs)> String(str)
  lookup-constructor-from-identifier(|rs): Error() -> []


  /** @type Rule(ID, List(RHS)) -> List(SDF3.SdfProductionWithCons) */
  rule-to-sdf3: Rule(lhs, rhss) ->
      <map-with-index(rhs-to-sdf3(|lhs, <length> filteredRhss))> filteredRhss
      // Removes all rules with `error` token in RHS. TODO do we really want to ignore the error?
      with filteredRhss := <remove-all(\ RHS(rhsSymbols, _, _) -> <getfirst(?Error())> rhsSymbols \)> rhss

  /**
   * @param lhs : string        The left-hand side of the original YACC rule.
   * @param rhsAmount : int     The amount of right-hand sides the original YACC rule has. 
   * @type (int, RHS(List(Identifier), Prec, Action)) -> SDF3.SdfProductionWithCons
   */
  rhs-to-sdf3(|lhs, rhsAmount): (index, RHS(rhsSymbols, prec, _)) -> SdfProductionWithCons(
        SortCons(
          SortDef(<capitalize-string> lhs)
        , Constructor(<conc-strings> (
            <capitalize-string> lhs
            // Add an index to the constructor only if the amount of rules > 1
          , <?1 < !"" + (!index ; int-to-string)> rhsAmount)
          )
        )
      , Rhs(<rhs-symbols-to-sdf3> rhsSymbols)
      , NoAttrs()
      )

  /**
   * If RHS is empty, it produces an empty string on the RHS.
   * Else, it maps the identifiers on the RHS to SDF3 sorts and literals.
   *
   * @type List(Identifier) -> List(SDF3.Sort | SDF3.Lit)
   */
  rhs-symbols-to-sdf3: [] -> [Lit("\"\"")]
  rhs-symbols-to-sdf3: rhsSymbols -> <map(identifier-to-sdf3)> rhsSymbols

  /** @type Identifier -> SDF3.Sort | SDF3.Lit */
  identifier-to-sdf3: ID(str) -> Sort(<capitalize-string> str)
  identifier-to-sdf3: String(str) -> Lit(str)
  identifier-to-sdf3: SQString(str) -> Lit(<double-quote> <un-single-quote> str)
  identifier-to-sdf3: Error() -> <fail> // Error()s should have been removed in rule-to-sdf3

  /**
   * Capitalizes the first string of the character
   *
   * @type string -> string
   * @fails Never
   */
  capitalize-string: string -> res
    with [h|tail] := <explode-string> string
       ; newH := <to-upper> h
       ; res := <implode-string> [newH|tail]
